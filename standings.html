<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Standings • Frozen Diamond Classic</title>
  <link rel="stylesheet" href="./styles.css" />
</head>

<body class="watermarkPage standingsPage">
  <header class="siteHeader">
    <nav class="nav">
      <a href="./">Home</a>
      <a href="./schedule.html">Schedule/Scores</a>
      <a href="./standings.html" class="active">Standings</a>
      <a href="./stats.html">Stats</a>
      <a href="./teams.html">Teams</a>
      <a href="./rules.html">Rules</a>
      <a href="./contacts.html">Contacts</a>
      <a href="./gallery.html">Gallery</a>
      <a href="./uploads.html">Uploads</a>
    </nav>

    <div class="brandCenter">
      <img src="./logo.png" alt="Frozen Diamond Classic Logo" class="logoImage">
      <h1>Frozen Diamond Classic</h1>
      <div class="tagline">Tournament Central</div>
    </div>
  </header>

  <main class="wrap">
    <section class="docSection">
      <h2>Standings</h2>
      <p class="muted">Auto-calculated from games marked <strong>Final</strong> in the Google Sheet.</p>

      <div class="card">
        <div class="cardBody">
          <div class="standingsMeta">
            <div id="standingsUpdated" class="muted small"></div>
          </div>

          <div class="tableWrap">
            <table id="standingsTable">
              <thead>
                <tr>
                  <th>Team</th>
                  <th>Wins</th>
                  <th>Losses</th>
                  <th>Ties</th>
                  <th>Runs For</th>
                  <th>Runs Against</th>
                  <th>Run Diff</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>

          <p id="standingsMsg" class="muted small" style="margin-top:12px;"></p>
        </div>
      </div>
    </section>
  </main>

  <script src="./data.js"></script>
  <script>
    const tbody = document.querySelector("#standingsTable tbody");
    const msgEl = document.getElementById("standingsMsg");
    const updatedEl = document.getElementById("standingsUpdated");

    function safe(v){ return String(v ?? "").trim(); }
    function isFinal(status){ return safe(status).toLowerCase() === "final"; }

    async function fetchCsv(url) {
      if (!url) throw new Error("Missing GAMES_CSV_URL in data.js");
      const bust = (url.includes("?") ? "&" : "?") + "t=" + Date.now();
      const res = await fetch(url + bust, { cache: "no-store" });
      if (!res.ok) throw new Error(`Failed to fetch games CSV (${res.status})`);
      return await res.text();
    }

    // Robust CSV parser (quoted commas safe)
    function parseCsv(text) {
      const rows = [];
      let row = [];
      let cur = "";
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        const next = text[i + 1];

        if (ch === '"') {
          if (inQuotes && next === '"') { cur += '"'; i++; }
          else inQuotes = !inQuotes;
          continue;
        }

        if (!inQuotes && ch === ",") { row.push(cur); cur = ""; continue; }

        if (!inQuotes && (ch === "\n" || ch === "\r")) {
          if (ch === "\r" && next === "\n") i++;
          row.push(cur); cur = "";
          if (row.some(v => safe(v) !== "")) rows.push(row);
          row = [];
          continue;
        }

        cur += ch;
      }
      row.push(cur);
      if (row.some(v => safe(v) !== "")) rows.push(row);

      const headers = (rows.shift() || []).map(h => safe(h).replace(/\s+/g,""));
      return rows.map(r => {
        const obj = {};
        headers.forEach((h, idx) => obj[h] = safe(r[idx]));
        return obj;
      });
    }

    function toNum(x){
      const n = Number(safe(x));
      return Number.isFinite(n) ? n : null;
    }

    // Resolve S1/W2/L3 style refs into actual team names using final scores
    function winnerLoser(game) {
      if (!isFinal(game.Status)) return null;
      const a = toNum(game.ScoreA);
      const b = toNum(game.ScoreB);
      if (a === null || b === null) return null;

      if (a === b) return { T: true, A: game.TeamA, B: game.TeamB };
      return a > b ? { W: game.TeamA, L: game.TeamB } : { W: game.TeamB, L: game.TeamA };
    }

    function resolveTeamRef(ref, teamsBySeed, gamesById) {
      if (!ref) return null;
      ref = safe(ref).toUpperCase();
      if (!ref) return null;

      const type = ref[0];
      const num = Number(ref.slice(1));
      if (!Number.isFinite(num)) return null;

      if (type === "S") return teamsBySeed.get(num) || null;

      const g = gamesById.get(num);
      if (!g) return null;

      const wl = winnerLoser(g);
      if (!wl) return null;

      // If the referenced prior game is a tie, downstream is undefined — return null so it shows TBD.
      if (wl.T) return null;

      return resolveTeamRef(type === "W" ? wl.W : wl.L, teamsBySeed, gamesById);
    }

    function buildStandings(teamNames) {
      const map = new Map();
      for (const name of teamNames) {
        if (!name) continue;
        map.set(name, { team: name, W: 0, L: 0, T: 0, RF: 0, RA: 0, RD: 0 });
      }
      return map;
    }

    function sortStandings(a, b) {
      // W desc, L asc, RD desc, RF desc, team name asc
      if (b.W !== a.W) return b.W - a.W;
      if (a.L !== b.L) return a.L - b.L;
      if (b.RD !== a.RD) return b.RD - a.RD;
      if (b.RF !== a.RF) return b.RF - a.RF;
      return a.team.localeCompare(b.team);
    }

    function renderRows(rows) {
      tbody.innerHTML = "";
      for (const r of rows) {
        const tr = document.createElement("tr");
        const cells = [
          r.team,
          r.W,
          r.L,
          r.T,
          r.RF,
          r.RA,
          (r.RD > 0 ? "+" : "") + r.RD
        ];
        for (const c of cells) {
          const td = document.createElement("td");
          td.textContent = c;
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
    }

    async function init() {
      msgEl.textContent = "";
      updatedEl.textContent = "";

      // Load games
      const gamesCsv = await fetchCsv(window.SHEET?.GAMES_CSV_URL);
      const gameRows = parseCsv(gamesCsv);

      const gamesById = new Map(
        gameRows.map(r => [Number(r.Game), r]).filter(([id]) => Number.isFinite(id))
      );

      // Load teams (preferred, for complete standings even before finals)
      let teamsBySeed = new Map();
      if (window.SHEET?.TEAMS_CSV_URL) {
        const teamsCsv = await (async () => {
          const bust = (window.SHEET.TEAMS_CSV_URL.includes("?") ? "&" : "?") + "t=" + Date.now();
          const res = await fetch(window.SHEET.TEAMS_CSV_URL + bust, { cache: "no-store" });
          if (!res.ok) throw new Error(`Failed to fetch teams CSV (${res.status})`);
          return await res.text();
        })();

        const teamRows = parseCsv(teamsCsv);
        teamsBySeed = new Map(
          teamRows.map(r => [Number(r.Seed), safe(r.TeamName)]).filter(([s,n]) => Number.isFinite(s) && n)
        );
      }

      const standings = buildStandings(Array.from(teamsBySeed.values()));

      // Process final games
      const finalGames = gameRows.filter(g => isFinal(g.Status));
      let counted = 0;

      for (const g of finalGames) {
        const scoreA = toNum(g.ScoreA);
        const scoreB = toNum(g.ScoreB);
        if (scoreA === null || scoreB === null) continue;

        const aName = resolveTeamRef(g.TeamA, teamsBySeed, gamesById);
        const bName = resolveTeamRef(g.TeamB, teamsBySeed, gamesById);
        if (!aName || !bName) continue;

        // Ensure entries exist (just in case)
        if (!standings.has(aName)) standings.set(aName, { team: aName, W:0, L:0, T:0, RF:0, RA:0, RD:0 });
        if (!standings.has(bName)) standings.set(bName, { team: bName, W:0, L:0, T:0, RF:0, RA:0, RD:0 });

        const a = standings.get(aName);
        const b = standings.get(bName);

        // Runs
        a.RF += scoreA; a.RA += scoreB;
        b.RF += scoreB; b.RA += scoreA;

        // W/L/T
        if (scoreA > scoreB) { a.W += 1; b.L += 1; }
        else if (scoreB > scoreA) { b.W += 1; a.L += 1; }
        else { a.T += 1; b.T += 1; }

        counted += 1;
      }

      // RD
      for (const v of standings.values()) v.RD = v.RF - v.RA;

      const rows = Array.from(standings.values()).sort(sortStandings);
      renderRows(rows);

      updatedEl.textContent = `Last updated: ${new Date().toLocaleString()}`;
      msgEl.textContent = counted
        ? `Standings based on ${counted} final game(s).`
        : `No final games yet — standings will populate once games are marked Final.`;
    }

    init().catch(err => {
      console.error(err);
      msgEl.textContent = "Standings error: " + err.message;
    });
  </script>
</body>
</html>
