<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Teams • Frozen Diamond Classic</title>
  <link rel="stylesheet" href="./styles.css" />
</head>

<body class="watermarkPage teamsPage">
  <header class="siteHeader">
    <nav class="nav">
      <a href="./">Home</a>
      <a href="./schedule.html">Schedule/Scores</a>
      <a href="./standings.html">Standings</a>
      <a href="./stats.html">Stats</a>
      <a href="./teams.html" class="active">Teams</a>
      <a href="./rules.html">Rules</a>
      <a href="./contacts.html">Contacts</a>
      <a href="./gallery.html">Gallery</a>
      <a href="./uploads.html">Uploads</a>
    </nav>

    <div class="brandCenter">
      <img src="./logo.png" alt="Frozen Diamond Classic Logo" class="logoImage">
      <h1>Frozen Diamond Classic</h1>
      <div class="tagline">Tournament Central</div>
    </div>
  </header>

  <main class="wrap">
    <section class="docSection">
      <h2>Teams</h2>
      <p class="muted">Tap a team to view its roster.</p>

      <div class="card">
        <div class="cardBody">
          <div id="teamsGrid" class="teamsGrid"></div>
          <p id="teamsMsg" class="muted small" style="margin-top:12px;"></p>
        </div>
      </div>
    </section>
  </main>

  <script src="./data.js"></script>
  <script>
    const grid = document.getElementById("teamsGrid");
    const msgEl = document.getElementById("teamsMsg");

    function safe(v){ return String(v ?? "").trim(); }
    function isFinal(status){ return safe(status).toLowerCase() === "final"; }

    async function fetchCsv(url, label) {
      if (!url) throw new Error(`Missing ${label}_CSV_URL in data.js`);
      const bust = (url.includes("?") ? "&" : "?") + "t=" + Date.now();
      const res = await fetch(url + bust, { cache: "no-store" });
      if (!res.ok) throw new Error(`Failed to fetch ${label} CSV (${res.status})`);
      return await res.text();
    }

    // Robust CSV parser (handles quoted commas)
    function parseCsv(text) {
      const rows = [];
      let row = [];
      let cur = "";
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        const next = text[i + 1];

        if (ch === '"') {
          if (inQuotes && next === '"') { cur += '"'; i++; }
          else inQuotes = !inQuotes;
          continue;
        }

        if (!inQuotes && ch === ",") { row.push(cur); cur = ""; continue; }

        if (!inQuotes && (ch === "\n" || ch === "\r")) {
          if (ch === "\r" && next === "\n") i++;
          row.push(cur); cur = "";
          if (row.some(v => safe(v) !== "")) rows.push(row);
          row = [];
          continue;
        }

        cur += ch;
      }
      row.push(cur);
      if (row.some(v => safe(v) !== "")) rows.push(row);

      const headers = (rows.shift() || []).map(h => safe(h).replace(/\s+/g,""));
      return rows.map(r => {
        const obj = {};
        headers.forEach((h, idx) => obj[h] = safe(r[idx]));
        return obj;
      });
    }

    function toNum(x){
      const n = Number(safe(x));
      return Number.isFinite(n) ? n : null;
    }

    function teamSlug(name) {
      return safe(name)
        .toLowerCase()
        .replace(/&/g, "and")
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/(^-|-$)/g, "");
    }

    // ---- Bracket resolver (S1/W2/L3 -> team name) ----
    function winnerLoser(game) {
      if (!isFinal(game.Status)) return null;
      const a = toNum(game.ScoreA);
      const b = toNum(game.ScoreB);
      if (a === null || b === null) return null;
      if (a === b) return { T: true, A: game.TeamA, B: game.TeamB };
      return a > b ? { W: game.TeamA, L: game.TeamB } : { W: game.TeamB, L: game.TeamA };
    }

    function resolveTeamRef(ref, teamsBySeed, gamesById) {
      if (!ref) return null;
      ref = safe(ref).toUpperCase();
      if (!ref) return null;

      const type = ref[0];
      const num = Number(ref.slice(1));
      if (!Number.isFinite(num)) return null;

      if (type === "S") return teamsBySeed.get(num) || null;

      const g = gamesById.get(num);
      if (!g) return null;

      const wl = winnerLoser(g);
      if (!wl || wl.T) return null;

      return resolveTeamRef(type === "W" ? wl.W : wl.L, teamsBySeed, gamesById);
    }

    function computeRecordMap(gameRows, teamsBySeed, gamesById) {
      const rec = new Map(); // teamName -> {W,L,T}

      function ensure(name){
        if (!rec.has(name)) rec.set(name, { W:0, L:0, T:0 });
        return rec.get(name);
      }

      for (const g of gameRows) {
        if (!isFinal(g.Status)) continue;

        const aScore = toNum(g.ScoreA);
        const bScore = toNum(g.ScoreB);
        if (aScore === null || bScore === null) continue;

        const aName = resolveTeamRef(g.TeamA, teamsBySeed, gamesById);
        const bName = resolveTeamRef(g.TeamB, teamsBySeed, gamesById);
        if (!aName || !bName) continue;

        const A = ensure(aName);
        const B = ensure(bName);

        if (aScore > bScore) { A.W++; B.L++; }
        else if (bScore > aScore) { B.W++; A.L++; }
        else { A.T++; B.T++; }
      }

      return rec;
    }

    function recordText(r){
      if (!r) return "0-0-0";
      return `${r.W}-${r.L}-${r.T}`;
    }

    function renderTeams(teamRows, recordMap) {
      grid.innerHTML = "";

      const teams = teamRows
        .map(r => ({ seed: Number(r.Seed), name: safe(r.TeamName) }))
        .filter(t => t.name)
        .sort((a,b) => (a.seed || 999) - (b.seed || 999));

      for (const t of teams) {
        const slug = teamSlug(t.name);

        const info = window.TEAM_INFO?.[slug] || {};
        const logo = info.logo || window.DEFAULT_TEAM_LOGO || "./logo.png";

        const a = document.createElement("a");
        a.className = "teamTile";
        a.href = `./team.html?team=${encodeURIComponent(slug)}`;

        const r = recordMap.get(t.name);

        // IMPORTANT: keep structure minimal so your existing tile sizing stays unchanged
        a.innerHTML = `
          <img class="teamTileLogo" src="${logo}" alt="${t.name} logo"
               onerror="this.onerror=null; this.src='${window.DEFAULT_TEAM_LOGO || "./logo.png"}';" />
          <div class="teamName">${t.name}</div>
          <div class="teamRecord">${recordText(r)}</div>
          <div class="viewRoster">View roster →</div>
        `;

        grid.appendChild(a);
      }
    }

    (async function init(){
      try {
        msgEl.textContent = "";

        const [teamsCsv, gamesCsv] = await Promise.all([
          fetchCsv(window.SHEET?.TEAMS_CSV_URL, "TEAMS"),
          fetchCsv(window.SHEET?.GAMES_CSV_URL, "GAMES")
        ]);

        const teamRows = parseCsv(teamsCsv);
        const gameRows = parseCsv(gamesCsv);

        const teamsBySeed = new Map(
          teamRows.map(r => [Number(r.Seed), safe(r.TeamName)]).filter(([s,n]) => Number.isFinite(s) && n)
        );

        const gamesById = new Map(
          gameRows.map(r => [Number(r.Game), r]).filter(([id]) => Number.isFinite(id))
        );

        const recordMap = computeRecordMap(gameRows, teamsBySeed, gamesById);

        renderTeams(teamRows, recordMap);

        const finalsCount = gameRows.filter(g => isFinal(g.Status)).length;
        msgEl.textContent = finalsCount ? `Records based on ${finalsCount} final game(s).` : "No final games yet.";
      } catch (err) {
        console.error(err);
        alert("Teams page error: check TEAMS_CSV_URL and GAMES_CSV_URL in data.js and make sure both tabs are published to CSV.");
      }
    })();
  </script>
</body>
</html>






